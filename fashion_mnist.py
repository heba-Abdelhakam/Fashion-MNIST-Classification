# -*- coding: utf-8 -*-
"""Fashion_MNIST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1spTogIxWt9sxm3UxKzom9yIg9uRQsCKn

### import Libraries
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

import tensorflow as tf
from tensorflow import keras

"""### Load Data"""

# Load the Fashion MNIST data
fmnist = tf.keras.datasets.fashion_mnist

# Load training and testing of Fashion MNIST data 
(train_images, train_labels), (test_images, test_labels) = fmnist.load_data()

print("• Length of Train Images :",len(train_images))
print("• Length of Test Images :",len(test_images))

"""### Explore Data

The images are 28x28 NumPy arrays, with pixel values ranging from 0 to 255.
"""

train_images.shape

"""The labels are an array of integers, ranging from 0 to 9."""

np.unique(train_labels)



"""### Preprocess the data"""

# Normalize the pixel values
train_images = train_images / 255.0
test_images = test_images / 255.0

# Reshape Images to put it in form DataDrame 
train_df = pd.DataFrame(train_images.reshape(len(train_images),-1))
train_df.head()

label_train_df = pd.DataFrame(train_labels.reshape(len(train_images),1), columns=['Label'])
label_train_df.head()

list_labels_train = label_train_df['Label'].tolist()
#list_labels_train

from sklearn.manifold import TSNE
tsne = TSNE(n_components=2, perplexity=45, random_state=123).fit_transform(train_df)
df_embd = pd.DataFrame(tsne, columns=['feature_1' ,'feature_2'])

df_embd

import seaborn as sns 
plt.figure(figsize=(15, 12))
#pal = sns.color_palette("hls",2)
sns.scatterplot(x = 'feature_1',
                y = 'feature_2',
                data = df_embd,
                hue = list_labels_train,
                palette='colorblind')
                #palette = pal)

"""We notice that there is overlapping between class (0, 2, 4, 6) --> (T-shirt, Pullover, Coat, Shirt), And we can say that these overlapping not strange to occur because these items sometimes have the similar shape.

![Capture2.PNG](data:image/png;base64,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)
"""

# Define Classes of Fashion
fmnist_classes = {0: 'T-Shirt',
                  1: 'Trouser',
                  2: 'Pullover',
                  3: 'Dress',
                  4: 'Coat',
                  5: 'Sandal',
                  6: 'Shirt',
                  7: 'Sneaker',
                  8: 'Bag',
                  9: 'Ankle Boot'}

# Select sample from training data to show it

# You can put between 0 to 59999 here
index = 55

# print the label of the image
print('•Label :', train_labels[index])

# print image in pixels
print('\n •Image In Pixel Array:\n',train_images[index])

# Visualize the image
plt.figure(figsize=(10,6))
plt.imshow(train_images[index], cmap=plt.cm.binary)

columns = 7
rows = 7
fig = plt.figure(figsize=(10, 10))

for i in range(1, columns * rows+1):
    data_idx = np.random.randint(len(train_images))
    img = train_images[data_idx].reshape([28, 28])
    label = fmnist_classes[train_labels[data_idx]]

    fig.add_subplot(rows, columns, i)
    plt.title(label)
    plt.imshow(img, cmap=plt.cm.binary)
    plt.axis('off')
plt.tight_layout()
plt.show()

idx = np.random.randint(len(train_images))
plt.imshow(np.squeeze(train_images[idx]), cmap='gray')
plt.axis('off')
plt.show()
print("Index of Image :",idx)
print("Target:", fmnist_classes[train_labels[idx]])





"""### Build Model

**• Simple Model**
"""

class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('accuracy') >= 0.90): # Experiment with changing this value
      print("\nReached 90% accuracy so cancelling training!")
      self.model.stop_training = True

callbacks = myCallback()

model = tf.keras.models.Sequential([
  tf.keras.layers.Flatten(),
  tf.keras.layers.Dense(128, activation=tf.nn.relu),
  tf.keras.layers.Dense(10, activation=tf.nn.softmax)
])
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

print("• Model Training")
model.fit(train_images, train_labels, epochs=5, callbacks=[callbacks])

print("\n• Model Evaluation")
model.evaluate(test_images, test_labels)

"""We will use convolutions to make accuracy better. This is the same neural network as earlier, but this time with Convolution and MaxPooling layers added first"""

# Define the model
model = tf.keras.models.Sequential([

  # Convolution Part
  tf.keras.layers.Conv2D(32, (3,3), activation="relu", input_shape=(28, 28, 1)),
  tf.keras.layers.MaxPooling2D(2, 2),
  tf.keras.layers.Conv2D(32, (3,3), activation="relu"),
  tf.keras.layers.MaxPooling2D(2, 2),
  # Neural Network Part                                    
  tf.keras.layers.Flatten(),
  tf.keras.layers.Dense(128, activation=tf.nn.relu),
  tf.keras.layers.Dense(10, activation=tf.nn.softmax)
])


model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

print("Model Training")
model.fit(train_images, train_labels, epochs=5)

print("Model Evaluation")
model.evaluate(test_images, test_labels)

class_names = ['T-shirt', 'Trouser', 'Pullover', 'Dress', 'Coat',
               'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle Boot']

"""#### **Make Predictions:**
With the model trained, you can use it to make predictions about some images. Attach a softmax layer to convert the model's linear outputs—logits—to probabilities, which should be easier to interpret.
"""

probability_model = tf.keras.Sequential([model, tf.keras.layers.Softmax()])
predictions = probability_model.predict(test_images)

def plot_image(i, predictions_array, true_label, img):
  true_label, img = true_label[i], img[i]
  plt.grid(False)
  plt.xticks([])
  plt.yticks([])

  plt.imshow(img, cmap=plt.cm.binary)

  predicted_label = np.argmax(predictions_array)
  if predicted_label == true_label:
    color = 'blue'
  else:
    color = 'red'

  plt.xlabel("{} {:2.0f}% ({})".format(class_names[predicted_label],
                                100*np.max(predictions_array),
                                class_names[true_label]),
                                color=color)

def plot_value_array(i, predictions_array, true_label):
  true_label = true_label[i]
  plt.grid(False)
  plt.xticks(range(10))
  plt.yticks([])
  thisplot = plt.bar(range(10), predictions_array, color="#777777")
  plt.ylim([0, 1])
  predicted_label = np.argmax(predictions_array)

  thisplot[predicted_label].set_color('red')
  thisplot[true_label].set_color('blue')

i = 0
plt.figure(figsize=(10,5))
plt.subplot(1,2,1)
plot_image(i, predictions[i], test_labels, test_images)
plt.subplot(1,2,2)
plot_value_array(i, predictions[i],  test_labels)
plt.show()

# Plot the first X test images, their predicted labels, and the true labels.
# Color correct predictions in blue and incorrect predictions in red.
num_rows = 5
num_cols = 3
num_images = num_rows*num_cols
plt.figure(figsize=(2*2*num_cols, 2*num_rows))
for i in range(num_images):
  plt.subplot(num_rows, 2*num_cols, 2*i+1)
  plot_image(i, predictions[i], test_labels, test_images)
  plt.subplot(num_rows, 2*num_cols, 2*i+2)
  plot_value_array(i, predictions[i], test_labels)
plt.tight_layout()
plt.show()

